<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPU Encoder Wedge Detection &amp; Kernel Panic Fix on Snapdragon X Elite | Saikiran</title>
    <link rel="icon" type="image/svg+xml" href="assets/favicon.svg">
    <meta name="description" content="How I diagnosed a wedged DPU encoder after long suspend with an external DP monitor on Snapdragon X Elite, fixed the resulting kernel panic and data corruption, and what still remains unsolved.">
    <meta property="og:title" content="DPU Encoder Wedge Detection &amp; Kernel Panic Fix on Snapdragon X Elite">
    <meta property="og:description" content="How I diagnosed a wedged DPU encoder after long suspend with an external DP monitor on Snapdragon X Elite, fixed the resulting kernel panic and data corruption, and what still remains unsolved.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="assets/favicon.svg">
    <meta name="twitter:card" content="summary">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="assets/css/style.css">

    <style>
        .post-hero {
            padding: 120px 0 40px;
        }

        .post-container {
            max-width: 780px;
            margin: 0 auto;
            padding: 0 var(--spacing-sm) var(--spacing-xl);
        }

        .post-meta {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-bottom: 2.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--surface-border);
        }

        .post-meta .date {
            font-size: 0.9rem;
        }

        .post-meta .read-time {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .post-back {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 2rem;
            transition: var(--transition);
        }

        .post-back:hover {
            gap: 0.8rem;
        }

        .post-title {
            font-size: 2.4rem;
            line-height: 1.2;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .post-subtitle {
            font-size: 1.15rem;
            color: var(--text-muted);
            margin-bottom: 2rem;
            line-height: 1.7;
        }

        .post-body h2 {
            font-size: 1.5rem;
            margin: 2.5rem 0 0.8rem;
            color: var(--text-main);
        }

        .post-body h3 {
            font-size: 1.15rem;
            margin: 2rem 0 0.6rem;
            color: var(--accent-primary);
        }

        .post-body p {
            color: var(--text-muted);
            line-height: 1.8;
            margin-bottom: 1.2rem;
        }

        .post-body strong {
            color: var(--text-main);
        }

        .post-body a {
            color: var(--accent-primary);
            text-decoration: underline;
            text-underline-offset: 3px;
        }

        .post-body a:hover {
            color: var(--accent-secondary);
        }

        .post-body ul, .post-body ol {
            padding-left: 1.5rem;
            margin-bottom: 1.2rem;
        }

        .post-body li {
            color: var(--text-muted);
            line-height: 1.8;
            margin-bottom: 0.4rem;
        }

        .post-body pre {
            background: #1e1e1e;
            border-radius: 10px;
            padding: 1.2rem 1.5rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            border: 1px solid #333;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.6;
            color: #abb2bf;
        }

        .post-body code {
            font-family: var(--font-mono);
            font-size: 0.88em;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 4px;
            padding: 0.1em 0.4em;
            color: var(--accent-primary);
        }

        .post-body pre code {
            background: none;
            border: none;
            padding: 0;
            color: inherit;
            font-size: inherit;
        }

        .post-body blockquote {
            border-left: 3px solid var(--accent-primary);
            padding: 0.8rem 1.5rem;
            margin: 1.5rem 0;
            background: rgba(59, 130, 246, 0.05);
            border-radius: 0 8px 8px 0;
        }

        .post-body blockquote p {
            margin-bottom: 0;
            font-style: italic;
        }

        .callout {
            background: rgba(59, 130, 246, 0.08);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 12px;
            padding: 1.2rem 1.5rem;
            margin: 1.5rem 0;
            display: flex;
            gap: 1rem;
            align-items: flex-start;
        }

        .callout i {
            color: var(--accent-primary);
            font-size: 1.1rem;
            margin-top: 0.1rem;
            flex-shrink: 0;
        }

        .callout p {
            margin-bottom: 0;
        }

        .commit-box {
            background: var(--surface-color);
            border: 1px solid var(--surface-border);
            border-radius: 12px;
            padding: 1.2rem 1.5rem;
            margin: 1.5rem 0;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .commit-box i {
            font-size: 1.5rem;
            color: var(--accent-secondary);
            flex-shrink: 0;
        }

        .commit-box .commit-hash {
            font-family: var(--font-mono);
            font-size: 0.82rem;
            color: var(--text-muted);
        }

        .commit-box a {
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 0.95rem;
        }

        @media (max-width: 768px) {
            .post-title { font-size: 1.8rem; }
        }
    </style>
</head>

<body>

    <!-- Skip to Content -->
    <a href="#main-content" class="skip-to-content">Skip to content</a>

    <!-- Reading Progress -->
    <div class="reading-progress" aria-hidden="true"></div>

    <!-- Navigation -->
    <nav class="navbar">
        <div class="container nav-container">
            <a href="index.html" class="logo">Sai<span class="accent">kiran</span>.</a>
            <ul class="nav-links">
                <li class="nav-dropdown">
                    <a href="index.html#professional-projects" class="nav-dropdown-toggle">Projects <i class="fas fa-chevron-down" style="font-size:0.65rem;margin-left:0.25rem;"></i></a>
                    <ul class="nav-dropdown-menu">
                        <li><a href="index.html#professional-projects"><i class="fas fa-briefcase"></i> Professional Projects</a></li>
                        <li><a href="index.html#projects"><i class="fas fa-code"></i> Personal Projects</a></li>
                    </ul>
                </li>
                <li><a href="index.html#linux-works">Linux Works</a></li>
                <li><a href="rust-playground.html">My Rust Playground</a></li>
                <li><a href="blog.html" class="active">Blogs</a></li>
                <li><a href="index.html#contact" class="btn btn-primary">Contact Me</a></li>
                <!-- Theme Toggle -->
                <li>
                    <button id="theme-toggle" class="theme-toggle-btn" aria-label="Switch theme" title="Switch theme">
                        <i class="fas fa-moon"></i>
                    </button>
                </li>
            </ul>
            <button class="menu-toggle" aria-label="Toggle navigation menu">
                <i class="fas fa-bars"></i>
            </button>
        </div>
    </nav>

    <main id="main-content">

    <div class="post-hero">
        <div class="post-container">

            <a href="blog.html" class="post-back"><i class="fas fa-arrow-left"></i> Back to Blog</a>

            <div class="tags" style="margin-bottom: 1.2rem;">
                <span class="tag">Linux Kernel</span>
                <span class="tag">DRM / DPU</span>
                <span class="tag">Snapdragon X Elite</span>
                <span class="tag">DisplayPort</span>
                <span class="tag">Suspend / Resume</span>
            </div>

            <h1 class="post-title">DPU Encoder Wedge Detection &amp; Kernel Panic Fix on Snapdragon X Elite</h1>
            <p class="post-subtitle">
                After long suspend with an external monitor connected, the Snapdragon X Elite's DPU vblank state
                freezes completely. Disconnecting the monitor then triggers a kernel panic and filesystem corruption.
                Here's how I detected the wedge, stopped the panic, and what's still left to solve.
            </p>

            <div class="post-meta">
                <span class="date"><i class="fas fa-calendar-alt" style="margin-right:0.3rem;"></i> February 2026</span>
                <span class="read-time"><i class="fas fa-clock" style="margin-right:0.3rem;"></i> ~10 min read</span>
                <span style="display:inline-flex;align-items:center;gap:0.4rem;background:rgba(34,197,94,0.1);border:1px solid rgba(34,197,94,0.3);border-radius:50px;padding:0.2rem 0.8rem;font-size:0.8rem;color:#22c55e;font-weight:600;"><i class="fas fa-circle-half-stroke"></i> Partially resolved — investigation ongoing</span>
            </div>

            <div class="commit-box">
                <i class="fab fa-github"></i>
                <div>
                    <div class="commit-hash">1aa9a6e074a6c32076772ae1b0aa54979bb0c639</div>
                    <a href="https://github.com/saikiran2001-v2/linux/commit/1aa9a6e074a6c32076772ae1b0aa54979bb0c639"
                       target="_blank" rel="noopener">View commit on GitHub <i class="fas fa-external-link-alt" style="font-size:0.75rem;"></i></a>
                </div>
            </div>

            <div class="post-body">

                <h2>Two bugs. One fixed. One open.</h2>
                <p>
                    This post is about a bug I've been chasing on the <strong>Lenovo Yoga Slim 7x</strong>
                    (Snapdragon X Elite X1E-80-100) with an external monitor connected over USB-C/DisplayPort.
                    It turned out to be two separate but related problems:
                </p>
                <ul>
                    <li><strong>Bug A</strong> — After long suspend, the external monitor does not turn back on.
                        The DPU vblank state is completely frozen. <em>(Still unsolved — under active investigation.)</em></li>
                    <li><strong>Bug B</strong> — When you try to disconnect the frozen monitor, the kernel
                        panics, the watchdog reboots the machine, and you risk filesystem corruption.
                        <em>(Fixed by this patch.)</em></li>
                </ul>
                <p>
                    Most users only noticed Bug A. But Bug B was the more dangerous one.
                </p>

                <h2>Reproducing the Wedge</h2>
                <p>Setup:</p>
                <ul>
                    <li>Lenovo Yoga Slim 7x 14 — Snapdragon X Elite X1E-80-100</li>
                    <li>External monitor connected via USB-C DisplayPort</li>
                    <li><code>s2idle</code> — the only suspend state exposed on this platform</li>
                </ul>
                <p>
                    Leave the laptop suspended for an extended period with the external monitor connected.
                    On wake, the monitor stays black. <code>dmesg</code> immediately tells the story:
                </p>
                <pre><code>[ 6182.357935] [drm:dpu_encoder_phys_vid_wait_for_commit_done:545]
               [dpu error] vblank timeout: 80824302
[ 6182.357953] [drm:dpu_encoder_phys_vid_wait_for_commit_done [msm]]
               ERROR Encoder wedge detected: vblank value frozen at
               80824302 for 308 iterations
[ 6182.358169] [drm:dpu_kms_wait_for_commit_done:525]
               [dpu error] wait for commit done returned -110</code></pre>
                <p>
                    The flush register value <code>0x80824302</code> is stuck — it never clears to zero,
                    meaning the display pipeline's CTL flush never completes. The hardware is frozen.
                    No vblank interrupts are arriving on the DP encoder's ping-pong controller.
                </p>
                <p>
                    Now try to unplug the monitor. Without the fix, the system triggers a hard reboot.
                    With a filesystem that wasn't cleanly unmounted, you're looking at journal corruption.
                </p>

                <h2>Why the Disconnect Caused a Kernel Panic</h2>

                <h3>The standard disable sequence</h3>
                <p>
                    When you unplug a DisplayPort monitor, the DRM subsystem runs the
                    <code>drm_atomic_disable</code> path on the affected encoder:
                </p>
                <pre><code>msm_dp_bridge_atomic_disable()
  → msm_dp_ctrl_push_idle()     /* writes to DP controller registers */

msm_dp_bridge_atomic_post_disable()
  → msm_dp_display_disable()
    → msm_dp_ctrl_off()         /* disables mainlink, powers off PHY */

dpu_encoder_virt_atomic_disable()
  → dpu_encoder_wait_for_tx_complete()   /* waits for hardware idle */
  → dpu_encoder_resource_control()       /* MDSS register writes */</code></pre>
                <p>
                    Every one of those steps writes to MMIO registers on the display bus. When the DPU
                    hardware is frozen in a wedged state, the display clock domains are not reliably
                    responding. MMIO writes into dead hardware stall the CPU bus, the
                    <strong>watchdog fires</strong>, and the kernel reboots mid-operation.
                </p>

                <h3>The wedge detection gap</h3>
                <p>
                    The existing code had no mechanism to signal to the disable path that the
                    hardware was in an unresponsive state. The <code>is_wedged</code> concept
                    simply didn't exist. Every disable attempted a full hardware teardown
                    unconditionally.
                </p>

                <h2>The Fix: Three Parts</h2>

                <h3>Part 1 — Detecting the wedge in the physical encoder</h3>
                <p>
                    In <code>dpu_encoder_phys_vid_wait_for_commit_done()</code>, vblank timeouts were
                    already being logged but nothing tracked <em>whether the same stall repeated</em>.
                    The patch adds two fields to <code>struct dpu_encoder_phys</code>:
                    <code>last_vblank_timeout_val</code> and <code>vblank_timeout_count</code>.
                </p>
                <pre><code>/* dpu_encoder_phys_vid.c */
flush_register = hw_ctl->ops.get_flush_register(hw_ctl);
DPU_ERROR("vblank timeout: %x\n", flush_register);

if (flush_register != 0) {
    if (phys_enc->last_vblank_timeout_val == flush_register) {
        phys_enc->vblank_timeout_count++;

        if (phys_enc->vblank_timeout_count >= 3) {
            /* Same value frozen across 3+ timeouts → hardware is wedged */
            dpu_encoder_trigger_wedge_recovery(phys_enc->parent);
        }
    } else {
        /* Value changed, reset tracking */
        phys_enc->last_vblank_timeout_val = flush_register;
        phys_enc->vblank_timeout_count = 1;
    }
}</code></pre>
                <p>
                    The logic is conservative on purpose: a single timeout could be a slow frame.
                    A frozen identical value across three consecutive polls means the pipeline is
                    genuinely stuck. <code>dpu_encoder_trigger_wedge_recovery()</code> then sets
                    <code>is_wedged = true</code> on the virtual encoder.
                </p>
                <p>
                    A second, coarser detector also exists in the frame-done timer path:
                    five consecutive frame-done timeouts also trigger the wedge flag.
                </p>

                <h3>Part 2 — Safe atomic_disable that skips hardware</h3>
                <p>
                    <code>dpu_encoder_virt_atomic_disable()</code> now checks <code>is_wedged</code>
                    before touching any hardware. If set, it stops the frame-done timer first
                    (to prevent races), then performs a software-only teardown:
                </p>
                <pre><code>/* dpu_encoder.c */
/* Stop frame done timer FIRST to prevent races */
timer_delete_sync(&dpu_enc->frame_done_timer);

mutex_lock(&dpu_enc->enc_lock);
dpu_enc->enabled = false;

if (dpu_enc->is_wedged) {
    /* Software-only IRQ cleanup — NO hardware register access */
    for (i = 0; i < dpu_enc->num_phys_encs; i++) {
        struct dpu_encoder_phys *phys = dpu_enc->phys_encs[i];
        if (phys->hw_intf && phys->irq[INTR_IDX_VSYNC])
            dpu_core_irq_unregister_callback(phys->dpu_kms,
                                             phys->irq[INTR_IDX_VSYNC]);
        if (phys->hw_intf && phys->irq[INTR_IDX_UNDERRUN])
            dpu_core_irq_unregister_callback(phys->dpu_kms,
                                             phys->irq[INTR_IDX_UNDERRUN]);
    }
    dpu_enc->connector = NULL;
    mutex_unlock(&dpu_enc->enc_lock);
    return; /* Done — no MDSS register writes */
}</code></pre>

                <h3>Part 3 — DP bridge bypass during post_disable</h3>
                <p>
                    Even with the DPU encoder handled safely, the DP bridge still tried to write
                    to the DP controller registers in <code>msm_dp_bridge_atomic_disable()</code>
                    and <code>msm_dp_bridge_atomic_post_disable()</code>. A new public function
                    <code>dpu_encoder_is_wedged()</code> lets the DP layer query the state:
                </p>
                <pre><code>/* dp_display.c — atomic_disable */
if (drm_bridge->encoder &&
    dpu_encoder_is_wedged(drm_bridge->encoder)) {
    drm_dbg_dp(dp->drm_dev, "encoder wedged, skipping push_idle\n");
    return;
}
msm_dp_ctrl_push_idle(msm_dp_display->ctrl);</code></pre>
                <pre><code>/* dp_display.c — atomic_post_disable */
if (drm_bridge->encoder &&
    dpu_encoder_is_wedged(drm_bridge->encoder)) {
    /* Skip all MMIO — just update software state and release PM */
    mutex_lock(&msm_dp_display->event_mutex);
    dp->power_on = false;
    dp->link_ready = false;
    msm_dp_display->hpd_state = ST_DISCONNECTED;
    /* Flush stale HPD events so reconnection starts clean */
    msm_dp_display->event_gndx = msm_dp_display->event_pndx;
    msm_dp_display_handle_plugged_change(dp, false);
    pm_runtime_put_sync(&dp->pdev->dev);
    mutex_unlock(&msm_dp_display->event_mutex);
    return;
}</code></pre>
                <p>
                    The bonus here: flushing the stale HPD event queue
                    (<code>event_gndx = event_pndx</code>) means reconnecting the monitor starts
                    from a clean HPD state rather than replaying a corrupted one.
                </p>

                <h3>Bonus: pixel clock retry</h3>
                <p>
                    A separate but related instability: after deep sleep (<code>s2idle</code>),
                    the display clock controller GDSC and parent PLLs can take a moment to
                    re-stabilise after the atomic restore runs. The pixel clock enable was
                    failing with <code>-EBUSY</code>. The fix adds a small retry loop:
                </p>
                <pre><code>/* dp_ctrl.c */
for (retries = 0; retries < 5; retries++) {
    ret = clk_prepare_enable(ctrl->pixel_clk);
    if (!ret)
        break;
    usleep_range(2000, 5000);
}</code></pre>

                <h2>What This Fixes (and What It Doesn't)</h2>

                <div class="callout" style="background:rgba(34,197,94,0.08);border-color:rgba(34,197,94,0.25);">
                    <i class="fas fa-check-circle" style="color:#22c55e;"></i>
                    <p>
                        <strong>Fixed:</strong> Disconnecting a wedged external monitor no longer causes
                        a kernel panic, watchdog reboot, or filesystem corruption. The kernel now safely
                        bypasses all frozen hardware registers, tears down only software state, and leaves
                        the system stable.
                    </p>
                </div>

                <div class="callout" style="background:rgba(251,191,36,0.08);border-color:rgba(251,191,36,0.25);">
                    <i class="fas fa-triangle-exclamation" style="color:#fbbf24;"></i>
                    <p>
                        <strong>Still open:</strong> After a long suspend, the external monitor does not
                        turn back on. The DPU pipeline is frozen and needs to be recovered without
                        requiring a full reboot. The recovery worker intentionally does <em>not</em> attempt
                        a hardware reset right now — MMIO writes to frozen hardware on the display bus
                        can still cause bus errors and SError panics. A safe re-initialisation path
                        that properly re-clocks and restores the DPU state is still being worked on.
                    </p>
                </div>

                <h2>Why the Hardware Reset Is Non-Trivial</h2>
                <p>
                    The tempting fix is to just reset the DPU block and re-run the atomic state
                    restore. The problem is the ordering:
                </p>
                <ul>
                    <li>The MDSS power domain and display clocks must be revived before anything
                        is written to MMIO — but they were collapsed by firmware during deep sleep,
                        and the driver's runtime PM reference counts are no longer in sync with reality.</li>
                    <li>The DRM atomic state machine doesn't have a "partial re-enable" path —
                        you'd need to trigger a full modeset, which normally requires a userspace
                        <code>DRM_IOCTL_MODE_ATOMIC</code> call and not something you do from a timer
                        or workqueue.</li>
                    <li>Triggering a modeset from atomic context (e.g., from the frame-done timer
                        interrupt) causes a <code>scheduling while atomic</code> BUG.</li>
                </ul>
                <p>
                    The recovery worker currently just logs the wedge state and defers to the next
                    user-triggered <code>atomic_enable</code> (i.e., after a manual replug). Making
                    that happen automatically — and safely — without crashing the kernel is the
                    remaining problem.
                </p>

                <h2>Takeaways</h2>
                <ul>
                    <li><strong>Fix the dangerous bug first.</strong> The monitor-not-waking issue
                        is annoying; the kernel-panic-on-disconnect was dangerous. Scope your patch
                        narrowly to what you can prove correct and safe.</li>
                    <li><strong>Never write to MMIO when you don't know the clock state.</strong>
                        Any register access on a frozen display bus will stall the CPU. The entire
                        disable path must be gated on hardware liveness, not just software flags.</li>
                    <li><strong>A frozen flush register is a wedge signature.</strong>
                        The CTL flush register normally clears to zero on every vblank. If it
                        shows the same non-zero value across multiple consecutive timeouts,
                        the pipeline is not slow — it's dead.</li>
                    <li><strong>Don't reset from atomic context.</strong> IRQ handlers and timer
                        callbacks cannot call code that sleeps or schedules. Any recovery that
                        needs a full modeset must be deferred to a workqueue and even then must
                        coordinate with the DRM atomic state machine.</li>
                </ul>

                <div class="callout">
                    <i class="fas fa-code-branch"></i>
                    <p>
                        If you're running into this on your own Snapdragon X Elite machine,
                        the patch prevents the hard crash. You'll still need to replug the
                        monitor after waking from a long suspend — but at least you won't
                        lose unsaved work anymore. Follow the commit for updates as I work
                        on the full recovery path.
                    </p>
                </div>

            </div><!-- /.post-body -->

            <!-- Author / Back -->
            <div style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--surface-border); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
                <div>
                    <p style="font-weight:700; margin-bottom:0.2rem;">Jaya Saikiran Banigallapati</p>
                    <p style="color: var(--text-muted); font-size:0.9rem;">Linux Kernel Contributor &amp; Power Platform Developer</p>
                </div>
                <a href="blog.html" class="btn btn-secondary" style="margin-left:0;">
                    <i class="fas fa-arrow-left" style="margin-right:0.5rem;"></i> All Posts
                </a>
            </div>

        </div>
    </div>

    </main>

    <!-- Footer -->
    <footer>
        <div class="container footer-content">
            <div class="footer-left">
                <h3>Let's collaborate.</h3>
                <p>Open for opportunities in Power Platform development and Linux administration.</p>
                <div class="footer-buttons">
                    <div class="footer-buttons-row">
                        <a href="mailto:bjsaikiran@gmail.com" class="email-link"><i class="fas fa-envelope"></i> bjsaikiran@gmail.com</a>
                        <button class="btn-copy-email" onclick="copyEmail(this)" title="Copy email" aria-label="Copy email address"><i class="fas fa-copy"></i><span class="copy-tooltip">Copied!</span></button>
                    </div>
                    <a href="assets/Saikiran_Resume.pdf" download class="btn btn-secondary"><i class="fas fa-download"></i> Download Resume</a>
                </div>
            </div>
            <div class="footer-socials">
                <a href="https://github.com/saikiran2001-v2" target="_blank" class="social-icon" aria-label="GitHub profile"><i class="fab fa-github"></i></a>
                <a href="https://www.linkedin.com/in/jaya-saikiran-banigallapati-08a431177/" target="_blank" class="social-icon" aria-label="LinkedIn profile"><i class="fab fa-linkedin"></i></a>
            </div>
        </div>
        <div class="footer-bottom">
            <p>&copy; 2026 Jaya Saikiran Banigallapati. All rights reserved.</p>
        </div>
    </footer>

    <script src="assets/js/script.js"></script>
</body>

</html>
